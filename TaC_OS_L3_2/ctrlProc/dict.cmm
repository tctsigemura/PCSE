/*
 * controlProc/dict.cmm : 
 *
 * 2019.07.08           : 新規作成
 *
*/

#include <kernel.h>
#include <fatFs.h>
#include <util.h>

#include "dict.h"


int dictsize;
Entry[] dict = array(MAX_DICT_SIZE);


public int getDictLen() 
{  
    return dictsize;
}

public char[] getFileName(int i) 
{ 
    return dict[i].fileName; 
}

public int getIsdir(int i) 
{ 
    return dict[i].isdir; 
}


DIR dir = {null, 0, 0, 0, 0};
public void newDict(char[] path) 
{
    int fd = openDir(path);
    if (fd<0) 
    {
        panic("can't open the %s.", path);
    } 
    else 
    {
        int i = 0;
        while (readDir(fd, dir)>0) 
        {
            if (i >= MAX_DICT_SIZE) break;

            // reject the special path, "." and ".."
            if (strcmp(dir.name, ".") > 0) continue; 
            if (strcmp(dir.name, "..") > 0) continue;

            dict[i] = malloc(sizeof(Entry));
            dict[i].fileName = malloc(13);

            if ((dict[i].isdir =  dir.attr & 0x10) == 0)    // MP3ファイルなら
                strcpy(dict[i].fileName, dir.name, '\0');
            else                                            // ディレクトリなら
                strcpy(dict[i].fileName, dir.name, '.'); 

            i = i+1;
        }
        dictsize = i;
    }
    close(fd);
}


public void renewDict(char[] path) {
    for (int i=0; i<dictsize; i=i+1)    // 辞書の大きさ分の初期化を行う
    {
        free(dict[i].fileName);
        free(dict[i]);
    }

    newDict(path);      // recreate dict
}



/*
 * 線形合同法を用いたランダム生成
 */
#define A 5         // 4*X+1
#define B 1         // 奇数
#define M 256
int seed = 1;
int rand() { 
    seed = (seed * A + B) % M;
    return seed;
}


public void shuffle() { 
    int len = getDictLen();
    for (int i=0; i<len; i=i+1) {
        int j = rand()%(len-1);         // 乱数(0 ~ dictsize-1)
        Entry tmp = malloc(sizeof(Entry));
        tmp = dict[i];
        dict[i] = dict[j];
        dict[j] = tmp;
        free(tmp);
    }
}

